<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="js创建对象"/>




  <meta name="keywords" content="JavaScript, 学习笔记, Syouyu" />










  <link rel="alternate" href="/atom.xml" title="Syouyu">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2017/12/23/js创建对象/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> js创建对象 - Syouyu </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Syouyu</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Syouyu</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          js创建对象
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-23
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-目的"><span class="toc-text">1. 目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-工厂模式例子"><span class="toc-text">2. 工厂模式例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-存在问题"><span class="toc-text">3. 存在问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造函数模式"><span class="toc-text">构造函数模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-构造函数模式例子"><span class="toc-text">1. 构造函数模式例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-与工厂模式的不同"><span class="toc-text">2. 与工厂模式的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-解决工厂模式的不足"><span class="toc-text">3. 解决工厂模式的不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-构造函数的调用"><span class="toc-text">4. 构造函数的调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-存在问题"><span class="toc-text">5. 存在问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原型模式"><span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-目的-1"><span class="toc-text">1. 目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-原型模式例子"><span class="toc-text">2. 原型模式例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-理解原型对象"><span class="toc-text">3. 理解原型对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-属性在哪？"><span class="toc-text">4. 属性在哪？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-化简原型语法"><span class="toc-text">5. 化简原型语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-动态性问题"><span class="toc-text">6. 动态性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-存在问题"><span class="toc-text">7. 存在问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>工厂模式、构造函数模式、原型模式<br><a id="more"></a></p>
<hr>
<p><strong>Q:</strong> 为什么要选择下面所讲的模式创建对象？<br><strong>A:</strong> 因为虽然使用Object构造函数或者字面量(<code>var person={};</code>)可以创建单个对象,<br>但它会<strong>产生大量的重复性代码</strong>(重复创建类似的对象)，俗称重复造轮子。</p>
<hr>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a><strong>1. 目的</strong></h2><p>解决 <strong>使用同一个接口创建很多对象，导致产生大量重复代码</strong>的问题。</p>
<h2 id="2-工厂模式例子"><a href="#2-工厂模式例子" class="headerlink" title="2. 工厂模式例子"></a><strong>2. 工厂模式例子</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Amy"</span>,<span class="number">29</span>,<span class="string">"Nurse"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"John"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<h2 id="3-存在问题"><a href="#3-存在问题" class="headerlink" title="3. 存在问题"></a><strong>3. 存在问题</strong></h2><p>虽然解决了创建多个相似对象的问题，但<strong>没有解决对象识别的问题</strong><br>(person1/person2只知道自己来源于Object()，不知道自己从createPerson()中来)</p>
<hr>
<h1 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h1><h2 id="1-构造函数模式例子"><a href="#1-构造函数模式例子" class="headerlink" title="1. 构造函数模式例子"></a><strong>1. 构造函数模式例子</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Amy"</span>,<span class="number">29</span>,<span class="string">"Nurse"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"John"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<h2 id="2-与工厂模式的不同"><a href="#2-与工厂模式的不同" class="headerlink" title="2. 与工厂模式的不同"></a><strong>2. 与工厂模式的不同</strong></h2><ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
<li>构造函数以大写字母开头</li>
</ul>
<h2 id="3-解决工厂模式的不足"><a href="#3-解决工厂模式的不足" class="headerlink" title="3. 解决工厂模式的不足"></a><strong>3. 解决工厂模式的不足</strong></h2><p>因为person1和person2是通过<code>new Person()</code>构建的，所以person1和person2分别保存着Person的一个<strong>分别不同的实例</strong>。<br><strong>person1和person2中的<code>constructor</code>属性都指向Person。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert (person1.constructor == Person); <span class="comment">//true</span></div><div class="line">alert (person2.constructor == Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>所以，在使用<code>instanceof</code>操作符检测对象类型时，可以知道对象的类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert (person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert (person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div><div class="line">alert (person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line">alert (person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="4-构造函数的调用"><a href="#4-构造函数的调用" class="headerlink" title="4. 构造函数的调用"></a><strong>4. 构造函数的调用</strong></h2><p>对于前面<code>Person()</code>的例子可以通过下面的任何一种方式来调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当作构造函数使用</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Amy"</span>,<span class="number">29</span>,<span class="string">"Nurse"</span>);</div><div class="line">person.sayName(); <span class="comment">//"Amy"</span></div><div class="line"></div><div class="line"><span class="comment">// 作为普通函数调用</span></div><div class="line">Person(<span class="string">"John"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"John"</span></div><div class="line"></div><div class="line"><span class="comment">// 在另一个对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o,<span class="string">"Jimmy"</span>,<span class="number">28</span>,<span class="string">"Teacher"</span>);</div><div class="line">o.sayName(); <span class="comment">//"Jimmy"</span></div></pre></td></tr></table></figure>
<p>在作为普通函数调用时，因为<strong>不使用new操作符调用<code>Person()</code>，属性和方法都被添加给<code>window</code>对象。</strong> 因此可以使用<code>window</code>对象来调用<code>sayName()</code>方法，并返回”John”。</p>
<h2 id="5-存在问题"><a href="#5-存在问题" class="headerlink" title="5. 存在问题"></a><strong>5. 存在问题</strong></h2><p><strong>每个方法都要在每个实例上重新创建一遍。</strong><br>在前面的例子中，person1和person2都有一个名为<code>sayName()</code>的方法，<br>但是，这两个方法不是同一个Function的实例。（每个Person实例都包含一个不同的Function实例）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">┌─────────────────┐     ┌─────────────────┐</div><div class="line">│   person1       │     │   person2       │</div><div class="line">│       name      │     │       name      │</div><div class="line">│       age       │     │       age       │</div><div class="line">│       job       │     │       job       │</div><div class="line">│ Func sayName()  │     │ Func sayName()  │</div><div class="line">└─────────────────┘     └─────────────────┘</div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><strong>这样创建两个完成同样任务的Function实例没有必要。</strong><br>解决这个问题，可以通过把函数定义转到构造函数外部，在构造函数内部，<strong>将sayName属性设置成等于全局的sayName函数</strong>，这样person1和person2对象就共享了在全局作用域中定义的同一个sayName函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert (<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Amy"</span>,<span class="number">29</span>,<span class="string">"Nurse"</span>);</div><div class="line"></div><div class="line"></div><div class="line">┌─────────────────┐                       ┌─────────────────┐</div><div class="line">│   person1       │     ┌─────────┐       │   person2       │</div><div class="line">│       name      │     │ <span class="built_in">window</span>  │       │       name      │</div><div class="line">│       age       │     │         │       │       age       │</div><div class="line">│       job       │     │<span class="function"><span class="keyword">function</span> │       │       <span class="title">job</span>       │</span></div><div class="line"><span class="function">│      <span class="title">sayName</span>────┼────&gt;│<span class="title">sayName</span>(<span class="params"></span>)│&lt;──────┼─────<span class="title">sayName</span>     │</span></div><div class="line"><span class="function">└─────────────────┘     └─────────┘       └─────────────────┘</span></div></pre></td></tr></table></figure></p>
<p>这样虽然<strong>解决了两个函数做同一件事的问题</strong>，<br>但是<strong>如果对象需要定义很多方法，那么需要定义很多全局函数，这样的自定义引用类型就丝毫没有封装性可言。</strong></p>
<hr>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="1-目的-1"><a href="#1-目的-1" class="headerlink" title="1. 目的"></a><strong>1. 目的</strong></h2><p>使用原型对象可以<strong>让所有对象实例共享它所包含的属性和方法</strong>，不必在构造函数中定义对象的实例信息，可以<strong>将这些信息直接添加到原型对象中</strong>。解决了构造函数模式中，每个方法都要在每个实例上重新创建的问题</p>
<h2 id="2-原型模式例子"><a href="#2-原型模式例子" class="headerlink" title="2. 原型模式例子"></a><strong>2. 原型模式例子</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Amy"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Nurse"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">//"Amy"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line">person2.sayName(); <span class="comment">//"Amy"</span></div><div class="line"></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p><strong>以上<code>person1.sayName()</code>和<code>person2.sayName()</code>为什么返回的都是Amy？</strong><br>其实以上<code>person1.sayName()</code>和<code>person2.sayName()</code>都是是指向同一个<code>Person.prototype.sayName()</code>,<br>因为person1和person2实例中没有创建name属性，所以<code>sayName()</code>里面的name值都是指向原型链上的name。(<code>Person.prototype.name</code>)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert(Person.prototype.isPrototypeOf(person1)); <span class="comment">//true</span></div><div class="line">alert(Person.prototype.isPrototypeOf(person2)); <span class="comment">//true</span></div><div class="line"><span class="comment">// 上面可以说明person1和person2内部存在一个指向Person.prototype的指针。</span></div><div class="line"></div><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype); <span class="comment">//true </span></div><div class="line"><span class="comment">// 上面可以说明person1对象的原型是Person.prototype</span></div><div class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1.name); <span class="comment">//"Amy"</span></div><div class="line"><span class="comment">// 上面person1.name的值是通过原型继承，获取到原型对象中name属性的值</span></div></pre></td></tr></table></figure></p>
<h2 id="3-理解原型对象"><a href="#3-理解原型对象" class="headerlink" title="3. 理解原型对象"></a><strong>3. 理解原型对象</strong></h2><p><strong>为什么会出现以上的情况呢？</strong><br>回答这个问题，我们需要理解原型对象的运行机制。<br>每当代码读取某个对象某个属性时，都会执行一次<strong>搜索，目标是具有给定名字的属性</strong>。搜索首先<strong>从对象实例本身开始</strong>。</p>
<ol>
<li>如果在实例中找到了具体给定名字的属性，则<strong>返回该属性的值</strong>；</li>
<li>如果没有找到，则继续搜索指针指向的原型对象，<strong>在原型对象中查找具有给定名字的属性。</strong></li>
</ol>
<p><strong>我举个栗子，这样应该容易理解点：</strong><br>假如你们家有一件<strong>传家宝（具有给定名字的属性）</strong>，<br>有一天，你的朋友来你家想观赏一下这件传家宝，要你<strong>找出来（进行搜索）</strong>。<br>这时候，你发现这个<strong>传家宝不在自己这（给定名字的属性不在实例上）</strong>，<br>你就去找你的爸爸问：“<strong>爸爸，传家宝在你那吗？”（在原型对象中查找给定名字的属性）</strong><br>爸爸答：“<strong>传家宝在爸爸我这(在原型对象中找到给定名字的属性)</strong>”，<br>这样你就在爸爸那找到传家宝，<strong>并拿回去给朋友欣赏(返回该属性的值)</strong></p>
<p>这样，你也许会问，假如在爸爸那还是找不到呢？<br>假如在爸爸那找不到，你会<strong>继续问你的爷爷、曾祖父……（假设还存在）关于家里传家宝（继续在原型链上查找给定名字的属性）</strong><br>直到最后，怎么也找不到了，也许已经不见了（找不到，最终返回null）</p>
<p>也许你还会问假如<strong>传家宝就在我自己家呢（给定名字的属性在实例上）</strong>？<br>那就直接拿出来给朋友欣赏呗！(直接返回该属性的值)</p>
<p>以下代码在实例中创建该属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Amy"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Nurse"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.name = <span class="string">"John"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">alert(person1.name); <span class="comment">//"John"来自实例</span></div><div class="line">alert(person2.name); <span class="comment">//"Amy"来自原型</span></div></pre></td></tr></table></figure></p>
<p><strong>当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。</strong><br><strong>添加这个属性只会阻止我们访问原型中的那个属性，并不会修改原型中的那个属性。</strong><br><strong>通过设置实例中的属性为null并不能回复其指向原型的连接，只有使用delete操作符才可以完全删除实例中的属性。</strong></p>
<hr>
<h2 id="4-属性在哪？"><a href="#4-属性在哪？" class="headerlink" title="4. 属性在哪？"></a><strong>4. 属性在哪？</strong></h2><p>可以通过<code>hasOwnProperty()</code>方法和<code>in</code>操作符来确定该属性到底是在对象中还是在原型中。<br><code>hasOwnProperty()</code>方法:检测属性是否存在于实例中<br><code>in</code>操作符：对象能否访问到给定属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Amy"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Nurse"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//false</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line"><span class="comment">// 说明可以找到name，但是不再实例上</span></div><div class="line"></div><div class="line">person1.name = <span class="string">"John"</span>;</div><div class="line">alert(person1.name); <span class="comment">//"John"，来自实例</span></div><div class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//true</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line"><span class="comment">// 说明可以找到name，而且在实例上</span></div><div class="line"></div><div class="line">alert(person2.name); <span class="comment">//"Amy"，来自原型</span></div><div class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//false</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line"><span class="comment">// 说明可以找到name，但是不再实例上</span></div><div class="line"></div><div class="line"><span class="keyword">delete</span> person1.name;</div><div class="line">alert(person1.name); <span class="comment">//"Amy"，来自原型</span></div><div class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>));<span class="comment">//false</span></div><div class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1); <span class="comment">//true</span></div><div class="line"><span class="comment">// 说明可以找到name，但是不再实例上 delete实例上的属性成功</span></div></pre></td></tr></table></figure></p>
<h2 id="5-化简原型语法"><a href="#5-化简原型语法" class="headerlink" title="5. 化简原型语法"></a><strong>5. 化简原型语法</strong></h2><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>: Person, //通过<span class="keyword">constructor</span>可以确定对象的类型</div><div class="line">    name: "Amy",</div><div class="line">    age: 29,</div><div class="line">    job: "Nurse",</div><div class="line">    sayName: function()&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="6-动态性问题"><a href="#6-动态性问题" class="headerlink" title="6. 动态性问题"></a><strong>6. 动态性问题</strong></h2><p>当你看到原来原型语法可以这样化简时，你也许会很热衷于使用这样重写整个原型对象的方法构建原型对象，但是要注意一些问题。见下面代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">Person.prototype=&#123;</div><div class="line">    <span class="keyword">constructor</span>: Person, //通过<span class="keyword">constructor</span>可以确定对象的类型</div><div class="line">    name: "Amy",</div><div class="line">    age: 29,</div><div class="line">    job: "Nurse",</div><div class="line">    sayName: function()&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName(); <span class="comment">//error</span></div></pre></td></tr></table></figure></p>
<p>以上代码为什么会错误呢？<br>首先，创建了一个名为friend的Person的实例，然后又重写了其原型对象。<br>其实，最后<code>friend.sayName();</code>出现错误是因为，<br><strong>friend指向的原型依然是当初实例化时候的原型，并不是后来重写的原型。</strong><br><strong>解决方法：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line">friend.sayName(); <span class="comment">//"Amy"</span></div></pre></td></tr></table></figure></p>
<h2 id="7-存在问题"><a href="#7-存在问题" class="headerlink" title="7. 存在问题"></a><strong>7. 存在问题</strong></h2><ol>
<li>假如在实例上不设置初始化属性，所有实例在默认情况下都会取得相同的属性值。</li>
<li>其共享本性不适合包含引用类型值的属性。<br>例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>: Person, //通过<span class="keyword">constructor</span>可以确定对象的类型</div><div class="line">    name: "Amy",</div><div class="line">    age: 29,</div><div class="line">    job: "Nurse",</div><div class="line">    friends: ["Shelby","Court"], //数组类型</div><div class="line">    sayName: function()&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line"></div><div class="line">alert(person1.friends); <span class="comment">//"Shelby","Court","Van"</span></div><div class="line">alert(person2.friends); <span class="comment">//"Shelby","Court","Van"</span></div><div class="line"></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">//true</span></div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以，哪一种创建对象的模式是最好的呢？我的答案是没有一种是最好的，因为它们各有缺点。<br>总的来说只有把这些模式<strong>组合起来使用</strong>，<br><strong>构造函数模式用于定义实例属性，</strong><br><strong>原型模式用于定义方法和共享的属性，</strong><br>在合适正确的场景下利用各自模式的特色和优点才是对于这个场景下最适合的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数模式用于定义实例属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>,<span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型模式用于定义方法和共享的属性</span></div><div class="line">person.prototype = &#123;</div><div class="line">    construtor: Person,</div><div class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Amy"</span>,<span class="number">29</span>,<span class="string">"Nurse"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"John"</span>,<span class="number">27</span>,<span class="string">"Doctor"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line">alert(person1.friends); <span class="comment">//"Shelby","Court,Van"</span></div><div class="line">alert(person2.friends); <span class="comment">//"Shelby","Court" </span></div><div class="line"><span class="comment">// person1中friends和person2中friends互不影响</span></div><div class="line"></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">//false 两个不同的数组</span></div><div class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true 指向同一方法</span></div></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>总结源于JavaScript 高级程序设计（第3版）P144~160 创建对象</strong></li>
</ul>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://yoursite.com">Syouyu</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://yoursite.com/2017/12/23/js创建对象/">http://yoursite.com/2017/12/23/js创建对象/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span>
      
      
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JavaScript/">JavaScript</a>
            
              <a href="/tags/学习笔记/">学习笔记</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
    
      <a class="next" href="/2017/12/18/Array类型学习笔记/">
        <span class="next-text nav-default">Array类型学习笔记</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:921393502@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/syou-yu" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="http://www.jianshu.com/u/23bdc8ac2543" class="iconfont icon-jianshu" title="jianshu"></a>
        
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2016 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Syouyu</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
